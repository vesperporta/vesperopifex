/** * @author:		Laurence Green * @email:		contact@laurencegreen.com * @www:		http://www.laurencegreen.com/ * @code:		http://vesper-opifex.googlecode.com/ * @blog:		http://vesperopifex.blogspot.com/ * The MIT LicenseCopyright (c) 2008-2009 Laurence GreenPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE. */package com.vesperopifex.display.book {	import com.vesperopifex.audio.AudioManager;	import com.vesperopifex.display.GraphicComponentObject;	import com.vesperopifex.display.IXMLDataObject;	import com.vesperopifex.display.SimpleInformationPanel;	import com.vesperopifex.display.accessibility.GraphicAccessibility;	import com.vesperopifex.display.book.utils.PageManager;	import com.vesperopifex.events.PageManagerEvent;	import com.vesperopifex.utils.Settings;	import com.vesperopifex.utils.XMLGraphicDisplay;	import com.vesperopifex.utils.controllers.PageEventControl;	import com.vesperopifex.xml.XMLFactory;		import flash.display.DisplayObject;		public class GraphicPage extends SimpleInformationPanel implements IChapter 	{		public static const XML_PAGE:String				= "page";		public static const XML_ACTIVE:String			= "active";		public static const XML_DIRECTORY:String		= "directory";		public static const XML_PAGE_ID:String			= "id";				protected var _parent:GraphicPage				= null;		protected var _manager:PageManager				= null;		protected var _isOpen:Boolean					= false;		protected var _id:String						= null;		protected var _pageReference:Array				= null;		protected var _currentPage:GraphicPage			= null;		protected var _stopImmediateOpening:Boolean		= false;		protected var _stopImmediateClosing:Boolean		= false;		protected var _pageChildren:Array				= new Array();		protected var _initiated:Boolean				= false;		protected var _loadersInactive:Boolean			= false;		protected var _persitent:Boolean				= false;		protected var _handleComplete:Boolean			= true;				public function get length():uint { return _pageChildren.length; }				public function get children():Array { return _pageChildren; }				/**		 * id :: common function to return _id		 * @return	<String>		 */	    public function get id():String { return _id; }		 		/**		 * path :: get path of this within the heirachy		 * @return	<String>	value of this current path		 */		public function get path():String { return (_parent == null)? "": _parent.path +"/" + _id; }				/**		 * isOpen :: getter returns if this page is open and visible.		 * @return	<Boolean>	a value denoting if this GraphicPage is currently open, true, or closed, false.		 */		public function get isOpen():Boolean { return _isOpen; }				/**		 * pageReference :: returns a stored string of a requested link.		 * @return	<Array>	an internal link for a specified page.		 */		public function get pageReference():Array { return _pageReference; }		public function set pageReference(value:Array):void 		{			_pageReference = value;		}				/**		 * getter pageData :: returns the stored XML for this GraphicPage.		 */		public function get pageData():XML { return _data; }				public function get currentPage():GraphicPage { return _currentPage; }		public function set currentPage(value:GraphicPage):void 		{			_currentPage = value;		}				public function get manager():PageManager { return _manager; }		public function set manager(value:PageManager):void 		{			_manager = value;			for each (var page:GraphicPage in _pageChildren) 			{				page.manager	= value;				page.addEventListener(PageManagerEvent.EXIT, value.pageChangeHandler);			}		}				/**		 * set a reference to the parent node		 * @param	node	<Chapter>	The parent node in the heirachy		 */		public function set Parent(chapter:GraphicPage):void 		{			_parent = chapter;		}				/**		 * Parent :: get a reference to the parent node		 * @return	<Chapter>		 */		public function get Parent():GraphicPage { return _parent; }				public function get graphicChildren():Array { return _children; }				public override function set XMLData(value:XML):void 		{			return;		}				/**		 * GraphicPage :: Constructor.		 * @param	id	<String>	identifyer for this GraphicPage object.		 * @param	xml	<XMLList>	data for construction of this GraphicPage object.		 */		public function GraphicPage(id:String, data:XML = null) 		{			_controller		= new PageEventControl(this);			super();			_id				= id;			_data			= data;			init();		}				/**		 * setup the current page.		 */				protected function init():void 		{			var item:XML	= null;			visible			= false;			name			= _id;			for each (item in _data[XMLFactory.XML_CONTENT]) checkEventControl(this, item);			if (_data.@[XMLFactory.XML_PERSISTENT].length()) _persitent	= (String(_data.@[XMLFactory.XML_PERSISTENT]) == "true")? true: false;			visible			= _persitent;			XMLGraphicDisplay.applyGraphicDetails(new GraphicComponentObject(this, int.MIN_VALUE, _data));			buildHierarchy();		}				/**		 * if any further pages are found as child nodes in the XML then generate and add them to the display stack.		 */				protected function buildHierarchy():void 		{			var item:XML			= null;			var page:GraphicPage	= null;			for each (item in _data[XML_PAGE]) 				if (String(item.@[XML_ACTIVE]) == "true") 				{					if (item.@[XML_DIRECTORY].length() > 0) 						page		= new GraphicPreloadPage(String(item.@[XML_PAGE_ID]), item, Settings.LANGUAGE);					else 						page		= new GraphicAnimatedPage(String(item.@[XML_PAGE_ID]), item);					AudioManager.checkPageAudioEvents(page, item);					add(page);				}		}				/**		 * add :: add a child to the stored pages Array and the render list while assigning this chapter as a parent to the child.		 * @param	child	<GraphicPage>	a basic constructor for either a Page or Chapter.		 */		public function add(page:GraphicPage):void 		{			_pageChildren.push(page);			addChild(page);			page.Parent = this;		}				/**		 * add all the finishing parts to the generated graphics.		 */		protected override function finishedGraphicGeneration():void 		{			if (_isOpen) return;			super.finishedGraphicGeneration();			animateOpenHandler();		}				/**		 * removeChildren :: remove all children from this Chapter's render list and clear the _pageChildren.		 */		public function removeChildren():void 		{			removePages();			removeGraphics();		}				/**		 * removeGraphics :: remove all Component classes from this GraphicChapter's render list and clear the _pageArray.		 */		protected override function removeGraphics():void 		{			for each (var object:GraphicComponentObject in _children) if (!(object is GraphicPage)) removeGraphicByComponentObject(object);			_children	= new Array();		}				/**		 * removePages :: remove all GraphicPage classes from this GraphicChapter's render list and clear the _pageChildren.		 */		public function removePages():void 		{			for each (var child:GraphicPage in _pageChildren) removePage(child);		}				/**		 * removePage :: remove the GraphicPage page from this GraphicChapter's render list.		 */		public function removePage(page:GraphicPage):void 		{			trace(Settings.FRAMEWORK + "PAGE REMOVED\\t:\t" + page.path);			if (page === this) 			{				for (var i:int = _pageChildren.length - 1; i >= 0; i--) safeRemovePage(_pageChildren[i]);				_pageChildren = new Array();				removeParent();			} else 				for (var j:int = _pageChildren.length - 1; j >= 0; j--) 					if (_pageChildren[j] == page) 					{						safeRemovePage(_pageChildren[j]);						_pageChildren.splice(j, 1);					}			dispatchEvent(new PageManagerEvent(PageManagerEvent.DELETE, true, false));		}				/**		 * safeRemovePage :: make sure that all child pages are removed before removing the direct decendant.		 * @param	page	<GraphicPage>	the target page to remove all children in the heirarchy.		 */		protected function safeRemovePage(page:GraphicPage):void 		{			page.removeGraphics();			if (page.length > 0) page.removePage(page);			else page.removeParent();		}				/**		 * checkEventControl :: get the page handler to deal with any available event instances present in the XML data.		 * @param	object	<DisplayObject>	the Object to listen for the events.		 * @param	data	<XML>	data pertaining to the object and teh attributes associated to it.		 */		protected function checkEventControl(object:DisplayObject, data:XML):void 		{			_controller.checkEvents(object, data);		}				/**		 * find if the passed DisplayObject is actually set as a child of the containing DisplayObject.		 * @param	child	<DisplayObject>	the child to determin if it is added as a child of this DisplayObject.		 * @return	<Boolean>	a true or false value indicating the childs state of being on this DisplayObjects display stack.		 */		protected function displayIndexChild(child:DisplayObject):Boolean 		{			var rtn:Boolean	= true;			try 			{				getChildIndex(child);			} catch (error:Error) 			{				rtn			= false;			}			return rtn;		}				/**		 * childrenXMLData :: loop through all the available children and return the available XML data for each object.		 * @return	<XML>	data pertaining to the entire component.		 */		protected function childrenXMLData():XML 		{			var gObject:GraphicComponentObject	= null;			var item:XML						= null;			var data:XML						= _data.copy();			var content:XML						= <content></content>;			if (!data.content.length()) data.appendChild(content);			else data.content					= content.copy();			for each (gObject in _children) 			{				if (gObject.graphic is IXMLDataObject) item	= (gObject.graphic as IXMLDataObject).XMLData.copy();				else item	= gObject.data.copy();				data.content.appendChild(item);			}			return data;		}				/**		 * childrenXMLData :: loop through all the available children and return the available XML data for each object.		 * @return	<XML>	data pertaining to the entire component.		 */		protected function pageXMLData():XML 		{			var data:XML			= childrenXMLData();			var pageData:XML		= new XML();			var item:XML			= null;			var pItem:XML			= null;			var page:GraphicPage	= null;			if (_pageChildren.length) 			{				for each (page in _pageChildren) 					if (page is IXMLDataObject) 						pageData.appendChild((page as IXMLDataObject).XMLData);			}			for each (item in data.page) 				for each (pItem in pageData.page) 					if (item != pItem && String(item.@id) == String(pItem.@id)) 						item = pItem.copy();			return data;		}				/**		 * getChild :: find the child with the passed identification.		 * @param	index	<String, int, or uint>	the identifying marker the page is located under.		 * @return	<GraphicPage>	a basic constructor for all Page's and Chapter's.		 */		public function getChild(index:Object):GraphicPage 		{			var rtn:GraphicPage	= null;			if (index is String) 				for each (rtn in _pageChildren) if (String(index) == rtn.id) return rtn;			var num:int		= int(index);			if (num >= 0 && num < _pageChildren.length && _pageChildren[num] is GraphicPage) rtn = _pageChildren[num];			return rtn;		}				/**		 * find if the depth index of the current page is correct taking into account the additional information from the XML data.		 */				protected function checkPageXMLIndex():void		{			for each (var page:GraphicPage in _pageChildren) XMLGraphicDisplay.checkXMLDisplayIndex(this, page, page.pageData);		}				/**		 * apply a loader visual to represent the amount of data loaded compared to the total		 */		protected override function addLoaderVisual():void 		{					}				/**		 * remove any loading visuals.		 */		protected override function removeLoaderVisual():void 		{			checkPageXMLIndex();		}				/**		 * findGraphic :: loop through all children and find is a DisplayObject is available with the identification passed.		 * @param	value	<String>	identification of the object to look for.		 * @return	<DisplayObject>	the object with which the identification is linked to.		 */		public function findGraphic(value:String):DisplayObject 		{			for each (var object:GraphicComponentObject in _children) 				if (object.data.@id == value) 					return object.graphic;			return null;		}				/**		 * remove this pages parent to allow for garbage collection.		 */				public function removeParent():void 		{			_parent = null;		}				/**		 * open :: common open function that all nodes must perform		 */		public function open():void 		{			if (_parent) 			{				if (_parent.isOpen) 				{					if (!_parent.currentPage || !_parent.currentPage.isOpen) openPage();					else if (_parent.currentPage.id != _id) 					{						_parent.currentPage.addEventListener(PageManagerEvent.CLOSE, parentCurrentPageCloseHandler);						_parent.currentPage.close();					} else if (_parent.currentPage.id == _id && !_isOpen) openPage();					else if (_currentPage && _currentPage.isOpen) 					{						_currentPage.addEventListener(PageManagerEvent.CLOSE, currentPageCloseHandler);						_currentPage.close();					}else trace("this page is already open " + _id);				} else				{					_parent.addEventListener(PageManagerEvent.OPEN, parentOpenHandler);					_parent.open();				}			} else openPage();		}				/**		 * openPage :: 		 */		protected function openPage():void 		{			if (!_initiated) 			{				generateGraphics();				_initiated	= true;			} else animateOpenHandler();		}				/**		 * remove all event listeners which occure in the natural handling of opening a page.		 */		public function stopImmediateOpening():void 		{			if (_parent) 			{				if (_parent.currentPage && _parent.currentPage.hasEventListener(PageManagerEvent.CLOSE)) 					_parent.currentPage.removeEventListener(PageManagerEvent.CLOSE, parentCurrentPageCloseHandler);			}			if (_currentPage && _currentPage.hasEventListener(PageManagerEvent.CLOSE)) 				_currentPage.removeEventListener(PageManagerEvent.CLOSE, currentPageCloseHandler);		}				/**		 * onOpenHandler :: parent node open event		 * @param	event	<PageManagerEvent>	event being passed to handler		 */		protected function parentOpenHandler(event:PageManagerEvent):void 		{			_parent.removeEventListener(PageManagerEvent.OPEN, parentOpenHandler);			openPage();		}				/**		 * animateOpenHandler :: current node opening animation.		 */		protected function animateOpenHandler():void 		{			opened();		}				/**		 * opened :: final call when opening the current page.		 */		protected function opened():void 		{			accessibility(true);			_isOpen								= true;			if (!visible) visible				= true;			if (_parent) _parent.currentPage	= this as GraphicPage;			activateChildGraphics();			trace(Settings.FRAMEWORK + "PAGE OPENED\t:\t" + path);			dispatchEvent(new PageManagerEvent(PageManagerEvent.OPEN, true, true));		}				protected function activateChildGraphics(value:Boolean = true):void		{			for each (var object:GraphicComponentObject in _children) 				if (object.graphic is IXMLDataObject) 					(object.graphic as IXMLDataObject).active	= value;		}				/**		 * close :: close the current component.		 */		public function close():void 		{			activateChildGraphics(false);			if (_currentPage) 			{				if (_currentPage.isOpen) 				{					_currentPage.addEventListener(PageManagerEvent.CLOSE, closeCurrentPageHandler);			 		_currentPage.close();				} else closePage();			} else closePage();		}				/**		 * stopImmediateClosing :: remove all event listeners associated to the natural closing of a page		 */		public function stopImmediateClosing():void 		{			if (_currentPage && _currentPage.hasEventListener(PageManagerEvent.CLOSE)) 				_currentPage.removeEventListener(PageManagerEvent.CLOSE, closeCurrentPageHandler);		}				/**		 * closePage :: override to run outro animation		 */		protected function closePage():void 		{			animateCloseHandler();		}				/**		 * animateCloseHandler :: parent node closing animation.		 */		protected function animateCloseHandler():void 		{			closed();		}				/**		 * closed :: final call when closing the current page.		 */		protected function closed():void 		{			accessibility(false);			_isOpen					= false;			if (visible) visible	= false;			trace(Settings.FRAMEWORK + "PAGE CLOSED\t:\t" + path);			dispatchEvent(new PageManagerEvent(PageManagerEvent.CLOSE, true, true));			visible					= _persitent;		}				/**		 * closeCurrentPageHandler :: child node close event handler		 * @param	event	<PageManagerEvent>	event being passed to handler		 */		protected function closeCurrentPageHandler(event:PageManagerEvent):void 		{			_currentPage.removeEventListener(PageManagerEvent.CLOSE, closeCurrentPageHandler);			closePage();		}				/**		 * parentCurrentPageCloseHandler :: parent node close event		 * @param	event	<PageManagerEvent>	event being passed to handler		 */		protected function parentCurrentPageCloseHandler(event:PageManagerEvent):void 		{			if (_parent) _parent.currentPage.removeEventListener(PageManagerEvent.CLOSE, parentCurrentPageCloseHandler);			openPage();		}				/**		 * currentPageCloseHandler :: current node close event		 * @param	event	<PageManagerEvent>	event being passed to handler		 */		protected function currentPageCloseHandler(event:PageManagerEvent):void 		{			if (_currentPage) _currentPage.removeEventListener(PageManagerEvent.CLOSE, currentPageCloseHandler);			openPage();		}				/**		 * changePage :: Dispatches a request to close the current page.		 */		public function changePage():void 		{			dispatchEvent(new PageManagerEvent(PageManagerEvent.EXIT, false, true));		}				/**		* change teh accessibility of the graphic children.		*/		protected function accessibility(enable:Boolean):void 		{			for each (var gObject:GraphicComponentObject in _children) 				if (gObject.graphic is IXMLDataObject && gObject.data) 					(enable)? GraphicAccessibility.enable(gObject): GraphicAccessibility.disable(gObject);		}			}	}